# :boom: Easy Maths :boom:

Welcome to Easy-Math! This repository is dedicated to collecting and organizing various math-related projects. Below, you'll find a brief description of each available repository, along with direct links to them.

## Practical Examples and Algorithms

| Preview | About |
|--------------|-------------|
| <p align="center">[<img src="https://github.com/JavierAM01/Deformacion-Continua-de-la-Esfera/blob/main/images/difeomorfismo_6.gif" height="250" width="250" />](https://github.com/JavierAM01/Deformacion-Continua-de-la-Esfera)</p> | <p align="center"> **Continuous Deformation of the Sphere**</p> In this repository, we explore the continuous deformation of the sphere and the stereographic projection from a mathematical perspective. Delving into the concepts of diffeomorphism, we study the smooth and bijective transformation of the sphere onto the plane, analyzing the geometric and topological properties involved. Using visualization techniques, we depict the results in graphs, allowing us to tangibly appreciate the effects of the deformation and stereographic projection. <br> <p align="center"><a href="https://github.com/JavierAM01/Deformacion-Continua-de-la-Esfera">See details</a></p> |
| <p align="center">[<img src="https://github.com/JavierAM01/Diagrama-de-Voronoi-y-Clustering/blob/main/images/p1_2.png" height="250" width="250" />](https://github.com/JavierAM01/Diagrama-de-Voronoi-y-Clustering)</p> | <p align="center"> **Voronoi Diagram and Clustering**</p> Clustering and Voronoi diagrams are fundamental tools in data analysis and visualization. Clustering groups similar data into homogeneous clusters, while Voronoi diagrams divide space into regions based on proximity to reference points. The combination of these techniques allows for effective pattern identification, data segmentation, and visualization of distributions, aiding the analysis of complex datasets. <br> <p align="center"><a href="https://github.com/JavierAM01/Diagrama-de-Voronoi-y-Clustering">See details</a></p> |
| <p align="center">[<img src="https://github.com/JavierAM01/Arbol-de-Huffman-y-Primer-Teorema-de-Shannon/blob/main/images/huffman.png" height="210" width="200" />](https://github.com/JavierAM01/Estructuras-de-datos)</p> | <p align="center"> **Data Structures** </p> This repository contains C++ implementations of several common data structures, including Huffman trees, queues, expression evaluation, and heaps. <br> <p align="center"><a href="https://github.com/JavierAM01/Estructuras-de-datos">See details</a></p> |
| <p align="center">[<img src="https://github.com/JavierAM01/Transformacion-Isometrica-Afin/blob/main/images/figura_3d_2.gif" height="250" width="250" />](https://github.com/JavierAM01/Transformacion-Isometrica-Afin)</p> | <p align="center"> **Affine Isometric Transformation** </p> Affine isometric transformation is a mathematical operation used in geometry to transform geometric figures on the plane. It is a rigid transformation that preserves distances between points and the proportions of figures, making it useful for maintaining symmetry and structure. Affine isometric transformations include rotations, translations, reflections, and combinations of these operations. They are important tools in geometry, allowing for precise and efficient figure transformations. <br> <p align="center"><a href="https://github.com/JavierAM01/Transformacion-Isometrica-Afin">See details</a></p> |
| <p align="center">[<img src="https://github.com/JavierAM01/Discretizacion-de-sistemas-dinamicos-continuos/blob/main/images/evolucion_diagrama_fases.gif" height="250" width="250" />](https://github.com/JavierAM01/Discretizacion-de-sistemas-dinamicos-continuos)</p> | <p align="center"> **Discretization of Continuous Dynamical Systems** </p> The discretization of continuous dynamical systems converts continuous systems into discrete ones for simulation and numerical analysis on digital computers. Discretization methods represent time and variables as discrete values, allowing for close approximations of continuous systems. <br> <p align="center"><a href="https://github.com/JavierAM01/Discretizacion-de-sistemas-dinamicos-continuos">See details</a></p> |
| <p align="center">[<img src="https://github.com/JavierAM01/Arbol-de-Huffman-y-Primer-Teorema-de-Shannon/blob/main/images/huffman.png" height="210" width="200" />](https://github.com/JavierAM01/Arbol-de-Huffman-y-Primer-Teorema-de-Shannon)</p> | <p align="center"> **Huffman Tree and Shannon's First Theorem** </p> The Huffman tree is a data compression algorithm that uses a binary tree structure to assign variable-length codes to each symbol in a dataset. Based on the symbolâ€™s probability, it constructs an optimal tree where more frequent symbols have shorter codes. In summary, the Huffman tree compresses data by assigning efficient codes to symbols based on their probability. <br> <p align="center"><a href="https://github.com/JavierAM01/Arbol-de-Huffman-y-Primer-Teorema-de-Shannon">See details</a></p> |

## Parallel Programming

| Preview | About |
|--------------|-------------|
| [<img src="https://github.com/JavierAM01/Cruzar-puente-Multiprocessing/blob/main/images/hist.gif" height="250" width="300"/>](https://github.com/JavierAM01/Cruzar-puente-Multiprocessing) | **Crossing a Bidirectional Bridge:** In this repository, you will delve into the world of process synchronization and critical section resolution using semaphores. We explore the implementation of a bidirectional bridge where only one type of pedestrian is allowed to cross at a time, avoiding starvation and traffic conflicts. By using the powerful "multiprocessing" library, we learn to efficiently manage critical sections and ensure smooth communication between processes. <p align="center"><a href="https://github.com/JavierAM01/Cruzar-puente-Multiprocessing">See details</a> </p> |
| [<img src="https://github.com/JavierAM01/Productor-Consumidor/blob/main/images/pc.jpg" height="170" width="300"/>](https://github.com/JavierAM01/Productor-Consumidor) | **Producer - Consumer:** The producer-consumer problem is a classic challenge in concurrent programming. It involves coordinating between producers and consumers to avoid race conditions and ensure data integrity. It is a fundamental example for understanding key concepts such as synchronization and communication between processes or threads. <p align="center"><a href="https://github.com/JavierAM01/Productor-Consumidor">See details</a> </p> |
| <p align="center">[<img src="https://github.com/JavierAM01/Juego-Arkanoid/blob/main/images/resumen/ejemplo.gif" height="250" width="250"/>](https://github.com/JavierAM01/Juego-Arkanoid)</p> | **Multiplayer Game:** In this project, we implement the Arkanoid game using parallel communication through multiprocessing libraries. We divide the work into several independent processes to improve performance and gameplay experience. We use inter-process communication to synchronize and share relevant information such as the platform's position, the ball's direction, and the state of the blocks. Additionally, we use shared data structures and variables to manage and share data between processes, ensuring mutual exclusion using locks. <p align="center"><a href="https://github.com/JavierAM01/Juego-Arkanoid">See details</a></p> |
| <p align="center">[<img src="https://github.com/JavierAM01/Analisis-de-Datos-con-BiciMad/blob/main/images/01-bicimad-escena-principal.gif" height="250" width="250"/>](https://github.com/JavierAM01/Analisis-de-Datos-con-BiciMad)</p> | **Parallel Data Analysis:** In this data analysis, we use PySpark to perform parallel processing of large data volumes. PySpark is a Python library that allows us to leverage the power of distributed processing using the Apache Spark framework. <p align="center"><a href="https://github.com/JavierAM01/Analisis-de-Datos-con-BiciMad">See details</a></p> |

## Theorems

### Proth's Theorem:

In this project, we present a demonstration of Proth's Theorem, accompanied by a small Python implementation. Proth's Theorem is an important result in number theory that establishes certain conditions for the existence of prime numbers of the form $k \cdot 2^n + 1$. Through our Python implementation, we can verify and demonstrate this theorem practically, allowing us to explore and better understand its properties and applications in number theory. <br> <p align="center"><a href="https://github.com/JavierAM01/Teorema-de-Proth">See details</a></p>

## Contributions

If you would like to contribute to any of the individual projects, be sure to visit the respective repositories

 linked above. Your contributions are welcome!

## Contact

If you have any questions or suggestions related to Easy-Math, feel free to contact me. You can find me on my GitHub profile: [JavierAM01](https://github.com/JavierAM01).

I hope you find these projects interesting and useful for your mathematical studies! Enjoy exploring the world of mathematics and its application in different areas.
